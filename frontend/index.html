<!DOCTYPE html>
<html lang="ru">

<head>
    <title>my_voice</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css">
    <link rel="stylesheet" href="css/fire.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/starts.css">
    <link href='https://fonts.googleapis.com/css?family=Lato:300,400,700' rel='stylesheet' type='text/css'>
</head>

<body>
<div id="stars"></div>
<div id="stars2"></div>
<div id="stars3"></div>

<div class="page-wrapper">
  <div class="left-panel-wrapper">
    <div class="left-panel">
      <div id="block-positive"><div class="block-title fire">Positive</div></div>
    </div>
  </div>

  <div class="content-wrapper">
    <div class="content">
        <div id="block-neutral"><div class="block-title fire">Neutral</div></div>
    </div>
  </div>

  <div class="right-panel-wrapper">
    <div class="right-panel">
        <div id="block-negative"><div class="block-title fire">Negative</div></div>
    </div>
  </div>
</div>
</body>
<!--<footer class="footer">-->
<!--    <div class="content has-text-centered">-->
<!--        <strong>my_voice</strong> by <div class="fire">Горящая лодка</div>. <a href="https://github.com/megarungle/my_voice"> The source code</a>-->
<!--    </div>-->
<!--</footer>-->

<script>
    async function postData(url = "http://localhost:8080/v1/models/test", data = {}) {
      const response = await fetch(url, {
        method: "GET",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
        },
        redirect: "follow",
        referrerPolicy: "no-referrer",
      });
      return await response.json();
    }

    postData().then((data) => {
        console.log(data);
        let i = 0
        for (let key in data) {
            let blocks = data[key];
            blocks.forEach(function (block) {
                let theme = block['theme'];
                let answers = block['answers'];
                createBlock(i, key);
                createCloud(i, answers, theme);
                i++;
            })
        }
    });

    function createBlock(id, sentiment) {
        let block = document.getElementById('block-' + sentiment);

        let cloudBlock = document.createElement('div');
        cloudBlock.classList.add('word-cloud');
        cloudBlock.setAttribute("id", "word-cloud" + id);
        block.appendChild(cloudBlock);
    }

    function createCloud(id, words, theme) {
        let config = {
            trace: true,
            spiralResolution: 0.8, //Lower = better resolution
            spiralLimit: 360 * 5,
            lineHeight: 0.8,
            xWordPadding: 0,
            yWordPadding: 0,
            font: "sans-serif"
        }

        words = words.map(function (word) {
            return {
                word: word,
                freq: Math.floor(Math.random() * 5) + 10 // шрифт взависимости от каунта
            }
        })

        words.push({"word": theme, "freq": 20});

        words.sort(function (a, b) {
            return -1 * (a.freq - b.freq);
        });

        let cloud = document.getElementById("word-cloud" + id);
        cloud.style.position = "relative";
        cloud.style.fontFamily = config.font;

        let startPoint = {
            x: cloud.offsetWidth / 2,
            y: cloud.offsetHeight / 2
        };

        let wordsDown = [];

        function createWordObject(word, freq) {
            let wordContainer = document.createElement("div");
            wordContainer.style.position = "absolute";
            wordContainer.style.fontSize = freq + "px";
            if (freq == 20) {
                wordContainer.style.fontWeight = "bold";
            }
            wordContainer.style.lineHeight = config.lineHeight;
            wordContainer.style.transform = "translateX(0%) translateY(0%)";
            wordContainer.appendChild(document.createTextNode(word));

            return wordContainer;
        }

        function placeWord(word, x, y) {

            cloud.appendChild(word);
            word.style.left = x - word.offsetWidth / 2 + "px";
            word.style.top = y - word.offsetHeight / 2 + "px";

            wordsDown.push(word.getBoundingClientRect());
        }

        function spiral(i, callback) {
            angle = config.spiralResolution * i;
            x = (1 + angle) * Math.cos(angle);
            y = (1 + angle) * Math.sin(angle);
            return callback ? callback() : null;
        }

        function intersect(word, x, y) {
            cloud.appendChild(word);

            word.style.left = x - word.offsetWidth / 2 + "px";
            word.style.top = y - word.offsetHeight / 2 + "px";

            let currentWord = word.getBoundingClientRect();

            cloud.removeChild(word);

            for (let i = 0; i < wordsDown.length; i += 1) {
                let comparisonWord = wordsDown[i];

                if (!(currentWord.right + config.xWordPadding < comparisonWord.left - config.xWordPadding ||
                    currentWord.left - config.xWordPadding > comparisonWord.right + config.wXordPadding ||
                    currentWord.bottom + config.yWordPadding < comparisonWord.top - config.yWordPadding ||
                    currentWord.top - config.yWordPadding > comparisonWord.bottom + config.yWordPadding)) {

                    return true;
                }
            }

            return false;
        }

        (function placeWords() {
            for (let i = 0; i < words.length; i += 1) {

                let word = createWordObject(words[i].word, words[i].freq);

                for (let j = 0; j < config.spiralLimit; j++) {
                    if (spiral(j, function () {
                        if (!intersect(word, startPoint.x + x, startPoint.y + y)) {
                            placeWord(word, startPoint.x + x, startPoint.y + y);
                            return true;
                        }
                    })) {
                        break;
                    }
                }
            }
        })();
    }

</script>

</html>